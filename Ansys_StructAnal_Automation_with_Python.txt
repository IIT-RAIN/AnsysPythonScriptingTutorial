import os, sys, clr, datetime

# Path to the Excel file containing input loads
input_excel_path = r"C:\path\to\input_loads.xlsx"
# Path for the new Excel file to save results
output_excel_path = r"C:\path\to\output_results.xlsx"
# Path for the image file to save the stress vs. load case plot
output_plot_path = r"C:\path\to\stress_plot.png"  
# Path for the log text file
output_log_path = r"C:\path\to\analysis_log.txt"  
# Name of the Named Selection in Mechanical that contains the joint's loaded surfaces
joint_surfaces_selection = "JointSurfaces" 

# Ensure the output directory exists (create if necessary)
output_dir = os.path.dirname(output_excel_path)
if output_dir and not os.path.exists(output_dir):
    os.makedirs(output_dir)

# Initialize log file
log_file = open(output_log_path, 'w')
log_file.write(f"Robot Joint Analysis Automation Log\n")
log_file.write(f"Start Time: {datetime.datetime.now()}\n")
log_file.write(f"Input file: {input_excel_path}\n")
log_file.write(f"Number of load components per case: 5 (Fx, Fy, Fz, Mx, My)\n\n")

# Function Definitions

def load_excel_data(file_path):
    # Read load cases from an Excel file and return a list of tuples (Fx, Fy, Fz, Mx, My)
    data = []
    try:
        # Use COM Interop to open Excel and read cells (IronPython can use .NET COM objects)
        clr.AddReference('Microsoft.Office.Interop.Excel')        # Add Excel interop assembly
        from Microsoft.Office.Interop import Excel
        excel_app = Excel.ApplicationClass()                      # Start Excel
        excel_app.Visible = False                                 # Excel runs in background
        workbook = excel_app.Workbooks.Open(file_path)
        sheet = workbook.Worksheets[1]                            # Use the first worksheet
        # Determine range of data (assuming continuous data in 5 columns)
        # Find last row by finding the last filled cell in first column
        last_row = sheet.Cells(sheet.Rows.Count, 1).End(Excel.XlDirection.xlUp).Row
        # Read each row of 5 columns
        for i in range(1, last_row + 1):
            fx = sheet.Cells(i, 1).Value2
            fy = sheet.Cells(i, 2).Value2
            fz = sheet.Cells(i, 3).Value2
            mx = sheet.Cells(i, 4).Value2
            my = sheet.Cells(i, 5).Value2
            # Ensure values are float (could be None if cell empty)
            if fx is None or fy is None or fz is None or mx is None or my is None:
                continue  # skip any incomplete rows
            data.append((float(fx), float(fy), float(fz), float(mx), float(my)))
        # Clean up: close workbook and quit Excel
        workbook.Close(SaveChanges=False)
        excel_app.Quit()
        # Release COM objects (to avoid Excel hanging in background)
        System.Runtime.InteropServices.Marshal.ReleaseComObject(sheet)
        System.Runtime.InteropServices.Marshal.ReleaseComObject(workbook)
        System.Runtime.InteropServices.Marshal.ReleaseComObject(excel_app)
    except Exception as err:
        log_file.write(f"ERROR: Failed to read Excel file '{file_path}'. Exception: {err}\n")
        raise
    # Log the number of cases read
    log_file.write(f"Loaded {len(data)} load cases from '{file_path}'.\n")
    return data

def apply_loads(force_obj, moment_obj, load_tuple):
    """Apply the given loads to the existing force and moment objects."""
    fx, fy, fz, mx, my = load_tuple
    # Apply force components
    force_obj.XComponent.Output.SetDiscreteValue(0, Quantity(fx, "N")) # Set Fx (N) at step index 0
    force_obj.YComponent.Output.SetDiscreteValue(0, Quantity(fy, "N"))   # Set Fy (N)
    force_obj.ZComponent.Output.SetDiscreteValue(0, Quantity(fz, "N"))   # Set Fz (N)
    # Apply moment components (assuming moments in N·m)
    moment_obj.XComponent.Output.SetDiscreteValue(0, Quantity(mx, "N*m"))# Set Mx (N·m)
    moment_obj.YComponent.Output.SetDiscreteValue(0, Quantity(my, "N*m"))# Set My (N·m)
    # Note: If Mz is needed, extend the input and add ZComponent similarly.
    # The objects are now updated with the new load values for this load case.

def run_simulation(analysis):
    """Solve the analysis and return True if successful, False if any error occurred."""
    try:
        analysis.Solve()  # Run the simulation for the current loads&#8203;:contentReference[oaicite:6]{index=6}
        return True
    except Exception as solve_err:
        log_file.write(f"ERROR: Solve failed for current load case. Exception: {solve_err}\n")
        return False

def extract_max_stress(stress_result):
    """Evaluate the equivalent stress result and return the maximum von Mises stress value."""
    stress_result.EvaluateAllResults()   # Ensure result is up-to-date (evaluate for current solution)
    max_stress = stress_result.Maximum  # Maximum von Mises stress from the result object (in Pa)
    return max_stress

# --- Main Automation Workflow ---

# 1. Read input load cases from Excel
load_cases = load_excel_data(input_excel_path)
if not load_cases:
    raise Exception("No load cases found in the input file or failed to read file.")

# 2. Get the Mechanical model and analysis objects
model = ExtAPI.DataModel.Project.Model          # Top-level model object&#8203;:contentReference[oaicite:7]{index=7}
analysis = model.Analyses[0]                    # Assuming first analysis is the one to use
# (If multiple analyses exist, you could select by name or index as needed.)

# 3. Ensure the joint surfaces named selection is available
ns_objects = ExtAPI.DataModel.Tree.GetObjectsByName(joint_surfaces_selection)
if not ns_objects:
    raise Exception(f"Named selection '{joint_surfaces_selection}' not found in the model.")
joint_ns = ns_objects[0]  # The named selection object representing joint surfaces

# 4. Add force and moment loads to the analysis, scoped to the joint surfaces
with ExtAPI.DataModel.Tree.Suspend():  # Suspend tree updates for performance&#8203;:contentReference[oaicite:8]{index=8}
    force_load = analysis.AddForce()   
    force_load.Name = "Joint Force"
    force_load.Location = joint_ns                    # Scope the force to the joint surfaces
    force_load.DefineBy = LoadDefineBy.Components     # Define force by components (Fx, Fy, Fz)
    moment_load = analysis.AddMoment()
    moment_load.Name = "Joint Moment"
    moment_load.Location = joint_ns                   # Scope the moment to the joint surfaces
    moment_load.DefineBy = LoadDefineBy.Components    # Define moment by components (Mx, My, Mz)

# 5. Add an equivalent stress result object (if not already present) to get von Mises stress
stress_result = None
for result in analysis.Solution.Children:
    # Identify if an Equivalent Stress result already exists
    if result.ObjectType == Ansys.ACT.Automation.Mechanical.Results.EquivalentStress:
        stress_result = result
        break
if stress_result is None:
    stress_result = analysis.Solution.AddEquivalentStress()
    stress_result.Name = "Equivalent Stress"
# By default, the Equivalent Stress result covers all bodies; no specific scoping is applied.

log_file.write("Applied initial force and moment objects and set up equivalent stress result.\n")
log_file.write(f"Running simulation for {len(load_cases)} load cases...\n\n")

# 6. Loop over each load case, apply loads, solve, and record results
max_stress_values = []  # to store max stress for each case
for idx, loads in enumerate(load_cases, start=1):
    fx, fy, fz, mx, my = loads
    log_file.write(f"Case {idx}: Fx={fx} N, Fy={fy} N, Fz={fz} N, Mx={mx} N*m, My={my} N*m ... ")
    apply_loads(force_load, moment_load, loads)   # update force and moment to current values
    success = run_simulation(analysis)            # solve the analysis for this load case
    if not success:
        log_file.write("Solve failed.\n")
        max_stress_values.append(None)
        continue  # proceed to next case despite failure
    # If solve succeeded, extract max von Mises stress
    max_stress = extract_max_stress(stress_result)
    max_stress_values.append(max_stress)
    # Log and optionally print the result (convert to a convenient unit, e.g., MPa)
    max_stress_MPa = max_stress / 1e6  # convert Pascals to MPa
    log_file.write(f"Max von Mises Stress = {max_stress_MPa:.2f} MPa\n")

# 7. After all cases, write the results to a new Excel file
try:
    # Create a new Excel workbook and sheet for output
    excel_app = Excel.ApplicationClass()        # reuse Excel COM (Excel assembly already referenced)
    excel_app.Visible = False
    out_workbook = excel_app.Workbooks.Add()
    out_sheet = out_workbook.Worksheets[1]
    # Write header row
    out_sheet.Cells(1, 1).Value2 = "Case"
    out_sheet.Cells(1, 2).Value2 = "Fx (N)"
    out_sheet.Cells(1, 3).Value2 = "Fy (N)"
    out_sheet.Cells(1, 4).Value2 = "Fz (N)"
    out_sheet.Cells(1, 5).Value2 = "Mx (N*m)"
    out_sheet.Cells(1, 6).Value2 = "My (N*m)"
    out_sheet.Cells(1, 7).Value2 = "Max Von Mises (Pa)"
    # Fill data rows
    row = 2
    for i, loads in enumerate(load_cases, start=1):
        fx, fy, fz, mx, my = loads
        max_stress = max_stress_values[i-1]
        out_sheet.Cells(row, 1).Value2 = i
        out_sheet.Cells(row, 2).Value2 = fx
        out_sheet.Cells(row, 3).Value2 = fy
        out_sheet.Cells(row, 4).Value2 = fz
        out_sheet.Cells(row, 5).Value2 = mx
        out_sheet.Cells(row, 6).Value2 = my
        if max_stress is not None:
            out_sheet.Cells(row, 7).Value2 = max_stress
        else:
            out_sheet.Cells(row, 7).Value2 = "SolveFailed"
        row += 1
    # Save the workbook to the specified file
    out_workbook.SaveAs(output_excel_path)
    out_workbook.Close(SaveChanges=True)
    excel_app.Quit()
    System.Runtime.InteropServices.Marshal.ReleaseComObject(out_sheet)
    System.Runtime.InteropServices.Marshal.ReleaseComObject(out_workbook)
    System.Runtime.InteropServices.Marshal.ReleaseComObject(excel_app)
    log_file.write(f"\nResults written to Excel file: {output_excel_path}\n")
except Exception as err:
    log_file.write(f"ERROR: Could not write results to Excel. Exception: {err}\n")

# 8. Create a plot of Max Stress vs Load Case index and save as an image
try:
    clr.AddReference('System.Windows.Forms')
    clr.AddReference('System.Windows.Forms.DataVisualization')
    from System.Drawing import Color
    from System.Windows.Forms.DataVisualization.Charting import Chart, ChartArea, Series, SeriesChartType, ChartImageFormat
    chart = Chart()
    chart.Width, chart.Height = 600, 400
    chart.ChartAreas.Add(ChartArea("MainArea"))
    series = Series("Max von Mises Stress")
    series.ChartType = SeriesChartType.Line
    series.Color = Color.Blue
    series.BorderWidth = 2
    # Populate series with data points
    for i, stress in enumerate(max_stress_values, start=1):
        if stress is not None:
            series.Points.AddXY(i, stress/1e6)  # use MPa for Y-axis for readability
    chart.Series.Add(series)
    # Set axis titles
    chart.ChartAreas["MainArea"].AxisX.Title = "Load Case"
    chart.ChartAreas["MainArea"].AxisY.Title = "Max von Mises Stress (MPa)"
    # Save chart to file
    chart.SaveImage(output_plot_path, ChartImageFormat.Png)
    log_file.write(f"Stress plot saved to: {output_plot_path}\n")
except Exception as err:
    log_file.write(f"ERROR: Plotting failed. Exception: {err}\n")

# 9. Finalize log
log_file.write(f"End Time: {datetime.datetime.now()}\n")
log_file.write("Analysis automation completed.\n")
log_file.close()
